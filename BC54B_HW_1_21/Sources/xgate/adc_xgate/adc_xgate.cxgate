#include "xgate.h"
#include "adc_xgate.hxgate"

//#include "ad_hardware.h"
//#include "pit_hardware.h"


 static unsigned short buffer[XADC0_SAMPLE_MAX_TIMES];
//#pragma push
//#pragma DATA_SEG __RPAGE_SEG XGATE_DATA
//static unsigned char index = 0;

static unsigned short high_buffer[SOC_ADC_SAMPLE_MAX_TIMES];
static unsigned short low_buffer[SOC_ADC_SAMPLE_MAX_TIMES];
static unsigned short single_buffer[SOC_ADC_SAMPLE_MAX_TIMES];
//#pragma DATA_SEG DEFAULT
//#pragma pop


void _sif(void);
/**
   adc0
**/
/***********************************************************************
  * @brief           向数组中插入数据
  * @param[in]       buf  数据存储区
  * @return          无
***********************************************************************/
static void adc_buffer_put_data(unsigned short *buf, unsigned char index, unsigned short value) {
    char i, j;

    for (i = 0; i < index; ++i) {
        if (value < buf[i]) break;
    }

    for (j = index; j > i; --j) {
        buf[j] = buf[j - 1];
    }

    buf[i] = value;
}



/***********************************************************************
  * @brief           PIT0 通道xgate中断处理函数
  * @param[in]       无
  * @return          无
***********************************************************************/
interrupt void xadc0_timer_xgate_isr(int noused) {
    (void)noused;
    // 清除中断标记.
    //PITTF_PTF0 = 1;
    PITTF = 1<<0;
    // 开始采集通道channel
    ATD0CTL5 = xadc0_data.param.channel;   //开始对应通道ad转换
}

/***********************************************************************
  * @brief           adc0 转换值滤波处理
  * @param[in]       无
  * @return          无
***********************************************************************/
static void cal_result() {
    signed char i;
    unsigned long tmp = 0;

    for (i = xadc0_data.param.times - xadc0_data.param.drop_high - 1;
            i >= xadc0_data.param.drop_low;
            --i) {
        tmp += buffer[i];

    }

    xadc0_data.result = (unsigned short)((unsigned long)(tmp + xadc0_data.left_times / 2) / xadc0_data.left_times);
  // xadc0_data.result = (unsigned short)((unsigned long)(tmp + (xadc0_data.left_times >> 1)) / xadc0_data.left_times);
}

#if 0
//Hanhui
void  Pit_Hardware_Stop(PitDev dev)
{
    PITCE &= ~(1<<dev);//关闭定时器
}


void Pit_Hardware_Clear_Time_out_Flag(PitDev dev)
{
    PITTF = 1<< dev; //清除溢出标志位 默认为0
}


void  Pit_Hardware_SetInterrupt(PitDev dev,INT8U set)
{
    if(set == 1)
        PITINTE &=(1<<dev); //开启定时器中断
    if(set == 0)
        PITINTE &=~(1<<dev); //关闭定时器中断
}
//Hanhui 
#endif 

/***********************************************************************
  * @brief           adc0 通道xgate中断处理函数
  * @param[in]       无
  * @return          无
***********************************************************************/     
interrupt void xadc0_adc_xgate_isr(int noused) {
    unsigned short tmp;
    (void)noused;
    //tmp = ATD0DR0;
     tmp = ATD0DR0;      //存储单次转换结果 

  
    PITTF_PTF0 = 1;     // 清除中断标记. adc0 转换是使用pit0 通断触发的
    //Pit_Hardware_Clear_Time_out_Flag(kPitDev0);
    
    adc_buffer_put_data(buffer, xadc0_data.sample_index, tmp);
    ++xadc0_data.sample_index;
    if(xadc0_data.sample_index < xadc0_data.param.times)
      return;
    else  ATD0CTL5 = xadc0_data.param.channel;   //开始对应通道ad转换 ？？ 是否应该加上个 liqing

    PITCE_PCE0 = 0;    //关闭PIT0使能
    PITINTE_PINTE0 = 0; //关闭PIT0通道中断使能
    cal_result();
    
   
    _sif();
}

/**
   adc1
**/

//void _sif(void);







/***********************************************************************
  * @brief           PIT1 通道xgate中断处理函数
  * @param[in]       无
  * @return          无
***********************************************************************/ 
interrupt void soc_adc_timer_isr(int noused) 
{
    (void)noused;
    // 开始采集通道2
    //PITTF_PTF1 = 1;
    PITTF = 1<<1;
    ATD1CTL5 = 2;
}

/***********************************************************************
  * @brief           软件中断1 通道xgate中断处理函数
  * @param[in]       无
  * @return          无
***********************************************************************/ 
interrupt void soc_adc_trigger_start_isr(int noused) {
    (void)noused;
    soc_xadc1_data.sample_index = 0;

    ATD1CTL5 = 2;
    PITCE_PCE1 = 0;     //关闭pit 通道1使能
    //PITTF_PTF1 = 1;
    PITTF = 1<<1;       //清标志位
    //PITFLT_PFLT1 = 1;
    PITFLT = 1<<1;     //计数使能位
    PITCE_PCE1 = 1;    //开启pit 通道1使能
    XGSWT = 0x02FD;    //清除软件中断标志位
}


        
static void cal_cc(void) 
{
    signed char i;
    unsigned long tmp1 = 0;
    unsigned long tmp2 = 0;
    unsigned long tmp3 = 0;
    for (i = soc_xadc1_data.param.times - soc_xadc1_data.param.drop_high - 1;
            i >= soc_xadc1_data.param.drop_low;
            --i)       //计算除掉最大值 和最小值后的 所有值的和
          {
             tmp1 += high_buffer[i];
             tmp2 += low_buffer[i];
             tmp3 += single_buffer[i];
          }
    asm {
         LOOP1: SSEM #SOC_ADC_SEM_NUM
         BCC LOOP1
        }

    //soc_adc_xgate_data.high = (unsigned short)((unsigned long)(tmp1 + left_times / 2) / left_times);
   // soc_adc_xgate_data.low = (unsigned short)((unsigned long)(tmp2 + left_times / 2) / left_times);
   // soc_adc_xgate_data.single = (unsigned short)((unsigned long)(tmp3 + left_times / 2) / left_times);
    
    soc_xadc1_data.high = (unsigned short)((unsigned long)(tmp1 + soc_xadc1_data.left_times / 2) / soc_xadc1_data.left_times);
    soc_xadc1_data.low = (unsigned short)((unsigned long)(tmp2 + soc_xadc1_data.left_times / 2) / soc_xadc1_data.left_times);
    soc_xadc1_data.single = (unsigned short)((unsigned long)(tmp3 + soc_xadc1_data.left_times / 2) / soc_xadc1_data.left_times);//  + left_times / 2 ??
    
    asm {
         CSEM #SOC_ADC_SEM_NUM
        }
}

/***********************************************************************
  * @brief           adc1 通道xgate中断处理函数
  * @param[in]       无
  * @return          无
***********************************************************************/ 
interrupt void soc_adc_adc1_isr(int noused) {
    unsigned short tmp;
    (void)noused;
    tmp = ATD1DR0;
    //PITTF_PTF1 = 1;
    PITTF = 1<<1;   //清中断标志位 PIT1 触发源
    if (ATD1CTL5 == 2) {
        adc_buffer_put_data(high_buffer, soc_xadc1_data.sample_index, tmp);
        ATD1CTL5 = 3; // 开启3通道采集.
        return;
    }
    if (ATD1CTL5 == 3) {
    adc_buffer_put_data(low_buffer, soc_xadc1_data.sample_index, tmp);
        ATD1CTL5 = 7; // 开启7通道采集.
        return;
    } 
    adc_buffer_put_data(single_buffer, soc_xadc1_data.sample_index, tmp);
    ATD1CTL5 = 2;    // 开启2通道采集.
    ++soc_xadc1_data.sample_index;                    //3个通道一次采集结束后 采集次数加1
    if (soc_xadc1_data.sample_index < soc_xadc1_data.param.times) return;
    cal_cc();
    soc_xadc1_data.sample_index = 0;
    _sif();
}
