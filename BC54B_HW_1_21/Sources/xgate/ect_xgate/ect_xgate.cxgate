#include "ect_xgate.hxgate"
#include "xgate.h"
#include "derivative.h"
#include "ect_intermediate.h"

#define MAX_INTERRUPT_TIME   3000  //定义最长中断函数使用的计数周期    0.5ms

CaptureSignal *pwm_list[5];

/***********************************************************************
  * @brief           用于对ECT模块捕捉信号中断处理
  * @param[in]       CaptureSignal结构体的参数
  * @return          无
***********************************************************************/

#if 0
interrupt void Capture_Hardware_ISR(CaptureSignal *__restrict pwm)
{
   //中断交给中断协处理器处理
    unsigned long tmp;
    unsigned char edge = PTT & pwm->port_t_bit;
    unsigned short this_capture = *(pwm->ect2_tc);


    ECT_TFLG1 = (unsigned char)(pwm->port_t_bit); // clear flag

    tmp = pwm->count_pre + (this_capture - pwm->last_capture);
    if (tmp < pwm->count_pre) {
        tmp = 0xFFFFFFFF;
    }

    asm {
        LOOP1: SSEM #PWM_SEM_NUM
        BCC LOOP1
    }

    if (edge) { // 上升沿
        pwm->low_cnt = tmp;
    } else {
        pwm->high_cnt = tmp;
    }
    asm {
        CSEM #PWM_SEM_NUM
    }

    pwm->count_pre = 0;
    pwm->last_capture = this_capture;
}
#endif 

interrupt void Capture_Hardware_ISR(CaptureSignal *__restrict pwm) {
    unsigned long tmp;
    unsigned char edge = PTT & pwm->port_t_bit;  //读取通道中断口的电平信号
    unsigned short this_capture = *(pwm->ect2_tc);   // TCn值  即本次计数值


    ECT_TFLG1 = (unsigned char)(pwm->port_t_bit); // clear flag
    

    /*
     出现异常的 可能
      1、两个中断同时触发
      2、其他中断占用xgate 同是 溢出中断和捕获相继到来
     时序分析
     
     在 设置溢出中断高于 捕捉中断时 分析
      1、同时触发 
         溢出中断先进入计算后将 pwm->last_capture 清零 保留差值  pwm->count_l32  在进入捕捉中断 得到的值=this_capture-pwm->last_capture+
         pwm->count_l32为正确值
      2、相继到来
         a、溢出中断先进入但是未执行，捕获随后来到了此时tc>0，等占用的其他中断结束，先执行溢出中断，之后流程同同时触发，计算结果正确需要注意的是在溢出中断更新值
         b、捕获中断先进入但是未执行tc>0,溢出中断随后到来， 等占用的其他中断结束，先执行溢出中断，此时 计算使用的pwm->last_capture 任然是
            前一次捕获的值，而不是本次未执行的捕获中断值，计算出错
      3、解决方案
        在计算溢出中断时，读取一次 tc值，如果tc值和 pwm->last_capture不同  说明有捕获中断进入还未执行 同时tc>pwm->last_capture 小于情况为a类型，不需要单独处理
         保存  pwm->count_l32 =  pwm->count_l32 + (this_capture - pwm->last_capture)，   pwm->last_capture = this_capture;
        
        在计算捕获中断里，判断如果 pwm->last_capture == this_capture 同时 this_capture>0 （排除同时为0的情况） 情况出现，此时电平计算值= pwm->count_l32；
        
        由于溢出中断已经出现并完成 需要给下次脉冲补上差值pwm->count_l32= 65536 -this_capture ； 
        
        
     
    */
    
    if(this_capture<pwm->last_capture)   //出错
    {
       pwm->last_capture = this_capture;
       pwm->count_pre = 0;    
      // return;                   //本次计算不要
    }
    else
    {
    
       tmp = pwm->count_pre + (this_capture - pwm->last_capture);
        
      if (tmp < pwm->count_pre) {
        tmp = 0xFFFFFFFF;
        }
        
        pwm->count_pre = 0;
        
        if((this_capture == pwm->last_capture) && this_capture > 0)   // 捕获中断先进入后执行的情况
        {
          pwm->count_pre = 65536 -  pwm->last_capture ;            //更新 下一次脉冲的偏移值
        
        }  
        
          pwm->last_capture = this_capture;        //更新 pwm->last_capture      
      
          asm {
                LOOP1: SSEM #PWM_SEM_NUM
                BCC LOOP1
              }       //共享区域读写保护

           if (edge) { // 上升沿
                      pwm->low_cnt = tmp;
                     }    
            else {
                     pwm->high_cnt = tmp;
                 }            
            
           asm {
                  CSEM #PWM_SEM_NUM
                }
     
    
    }
    

 

}

/***********************************************************************
  * @brief           用于对ECT模块输出比较功能的中断处理 
  * @param[in]       OutCompareSignal结构体的参数
  * @return          无
***********************************************************************/
interrupt void OutCompare_Hardware_ISR(OutCompareSignal *__restrict ect_compare)
{
    //中断交给中断协处理器处理
     ECT_TFLG1 = (unsigned char)(ect_compare->port_t_bit); // clear flag 
     /*
       根据需要添加用户中断处理函数  
     */
}


/***********************************************************************
  * @brief           用于对ECT模块计数器溢出中断处理
  * @param[in]       无
  * @return          无
***********************************************************************/
#if 0
interrupt void Counter_Overflow_Hardware_ISR(int unused)
{
     unsigned long tmp;
    unsigned char level;
    unsigned char i;
    CaptureSignal *pwm;  //这个定义是否有问题 

    (void)unused;
     //中断交给中断协处理器处理

    ECT_TFLG2 = ECT_TFLG2_TOF_MASK;

    for (i = 0; i < 5; ++i) {
        pwm = pwm_list[i];
        if (pwm == 0) break;

        level = PTT & pwm->port_t_bit;

        tmp = pwm->count_pre + (65536 - pwm->last_capture);
        pwm->last_capture = 0;
        if (tmp < pwm->count_pre) {
            tmp = 0xFFFFFFFF;
        }
        pwm->count_pre = tmp;

        asm {
            LOOP1: SSEM #PWM_SEM_NUM
            BCC LOOP1
        }

        if (level) {
            if (pwm->count_pre > pwm->high_cnt) {
                pwm->high_cnt = pwm->count_pre;
            }
        } else {
            if (pwm->count_pre > pwm->low_cnt) {
                pwm->low_cnt = pwm->count_pre;
            }
        }

        asm {
            CSEM #PWM_SEM_NUM
        }
    }
}
#endif 
interrupt void Counter_Overflow_Hardware_ISR(int unused) {
    unsigned long tmp;
    unsigned char level;
    unsigned char i;
     CaptureSignal *pwm;
     unsigned short this_capture ;   // TCn值  当前存储的计数值

    (void)unused;

    ECT_TFLG2 = ECT_TFLG2_TOF_MASK;

    for (i = 0; i < 5; ++i) {
        pwm = pwm_list[i];
        if (pwm == 0) break;
        this_capture = *(pwm->ect2_tc);   // TCn值  当前存储的计数值

        level = PTT & pwm->port_t_bit;   //后获取电平
       
       if( (this_capture > pwm->last_capture) && (this_capture > MAX_INTERRUPT_TIME))   //捕获中断先于溢出中断到来 但是还未执行
       {
         tmp = pwm->count_pre + (this_capture - pwm->last_capture);          
         pwm->last_capture = this_capture;
         
         //对pwm 已经停止的情况 this_capture值为恒定值，溢出中断时 会间隔进入 ，此时 pwm->count_l32 增大会减慢，不影响最后判断pwm断开的结果
       
          if (tmp < pwm->count_pre) { tmp = 0xFFFFFFFF; }
           pwm->count_pre = tmp;            
        
        // 在捕获中断先于溢出中断 但是被溢出中断抢先执行的情况，不对捕获结果的电平值处理，具体更新在捕获中断
       
       }
       else
       { 
         tmp = pwm->count_pre + (65536 - pwm->last_capture);
         
       
          if (tmp < pwm->count_pre) {
              tmp = 0xFFFFFFFF;
               }
           pwm->count_pre = tmp; 
           
        if((this_capture != pwm->last_capture) || (this_capture == 0) )  //当出现先溢出中断后捕获中断 或则 同时进入中断 但是捕获中断未执行时 出现电平已经翻转
           {
           asm {
               LOOP1: SSEM #PWM_SEM_NUM
               BCC LOOP1
              }   
    
            if (level)   //高电平
            {            
              if (pwm->count_pre > pwm->low_cnt) {
                 pwm->low_cnt = pwm->count_pre;
                   }
             } 
          else {
            if (pwm->count_pre > pwm->high_cnt) {
                pwm->high_cnt = pwm->count_pre;
                    }              
           }       

        asm {
            CSEM #PWM_SEM_NUM
       
            } 
        }        
          //在 this_capture == pwm->last_capture不更新电平值
          //应为在 电平计数值正好和 溢出中断的周期相同时，存在 溢出中断先触发 捕获中断后触发 值相等  
           //(pwm->count_l32 > 65536) 当脉冲结束时需要依靠这个来判断pwm 停止        
        else if(pwm->count_pre > 65536)
         {
          
        asm {
            LOOP2 : SSEM #PWM_SEM_NUM
            BCC LOOP2
           }
    
          if (level)   //高电平
          {
            if (pwm->count_pre > pwm->high_cnt) {
                pwm->high_cnt = pwm->count_pre;
            }
          } 
          else {
            if (pwm->count_pre > pwm->low_cnt) {
                pwm->low_cnt = pwm->count_pre;
            }
           }
       

        asm {
            CSEM #PWM_SEM_NUM
       
            }
         } 
         else ;             
            
            pwm->last_capture = 0;
        }
      }
}

/***********************************************************************
  * @brief           用于对ECT模块模数递减计数器溢出中断处理
  * @param[in]       无
  * @return          无
***********************************************************************/
interrupt void Modulus_Counter_Underflow_Hardware_ISR(int unused)
{
    //中断交给中断协处理器处理
     (void)unused;
     ECT_MCFLG = ECT_MCFLG_MCZF_MASK;   //清空flag标志
     /*
       根据需要添加用户中断处理函数  
     */
}


/***********************************************************************
  * @brief           用于对xgate模块软件中断0处理中断处理
  * @param[in]       无
  * @return          无
***********************************************************************/
interrupt void xgate_software_trigger0_isr(int unused) {
    char i;

    (void)unused;

    for (i = 0; i < sizeof(pwm_list) / sizeof(pwm_list[0]); ++i) {
        pwm_list[i] = 0;
    }
    pwm_list[0] = &cp_pwm_xgate_data;
    pwm_list[1] = &st1_pwm_xgate_data;
    pwm_list[2] = &st3_pwm_xgate_data;
    pwm_list[3] = &st5_pwm_xgate_data;
    pwm_list[4] = &st7_pwm_xgate_data;

    // Clear interrupt flag
    XGSWT = 0x01fe;

    // Enable ETC Overflow Interrupt
    ECT_TSCR2_TOI = 1;
    // Enable ETC
    ECT_TSCR1_TSWAI = 1;
    ECT_TSCR1_TEN = 1;

}